From 9961545020531867ea68876fca1be59ac8eeddb1 Mon Sep 17 00:00:00 2001
From: Abhijit Kulkarni <kabhijit@codeaurora.org>
Date: Wed, 15 Jun 2016 10:30:50 -0700
Subject: [PATCH] msm: mdss: hide kernel addresses from unprevileged users

for printing kernel pointers which should be hidden from unprivileged
users, use %pK which evaluates whether kptr_restrict is set.

CRs-Fixed: 987021
Change-Id: Ie49eee9478f4657cfb2a994ba60da1ec4c356339
Signed-off-by: Abhijit Kulkarni <kabhijit@codeaurora.org>
---

diff --git a/drivers/video/msm/mdss/mdp3.c b/drivers/video/msm/mdss/mdp3.c
index c1687a1..b68cdc5 100644
--- a/drivers/video/msm/mdss/mdp3.c
+++ b/drivers/video/msm/mdss/mdp3.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  * Copyright (C) 2007 Google Incorporated
  *
  * This software is licensed under the terms of the GNU General Public
@@ -1006,7 +1006,7 @@
 
 	mdp3_res->ion_client = msm_ion_client_create(mdp3_res->pdev->name);
 	if (IS_ERR_OR_NULL(mdp3_res->ion_client)) {
-		pr_err("msm_ion_client_create() return error (%p)\n",
+		pr_err("msm_ion_client_create() return error (%pK)\n",
 				mdp3_res->ion_client);
 		mdp3_res->ion_client = NULL;
 		return -EINVAL;
@@ -1429,7 +1429,7 @@
 	mutex_lock(&mdp3_res->iommu_lock);
 	meta = mdp3_iommu_meta_lookup(table);
 	if (!meta) {
-		WARN(1, "%s: buffer was never mapped for %p\n", __func__,
+		WARN(1, "%s: buffer was never mapped for %pK\n", __func__,
 				handle);
 		mutex_unlock(&mdp3_res->iommu_lock);
 		goto out;
@@ -1457,7 +1457,7 @@
 		} else if (meta->table > entry->table) {
 			p = &(*p)->rb_right;
 		} else {
-			pr_err("%s: handle %p already exists\n", __func__,
+			pr_err("%s: handle %pK already exists\n", __func__,
 				entry->handle);
 			BUG();
 		}
@@ -1519,7 +1519,7 @@
 	ret = iommu_map_range(domain, meta->iova_addr + padding,
 			table->sgl, size, prot);
 	if (ret) {
-		pr_err("%s: could not map %pa in domain %p\n",
+		pr_err("%s: could not map %pa in domain %pK\n",
 			__func__, &meta->iova_addr, domain);
 			unmap_size = padding;
 		goto out2;
@@ -1642,12 +1642,12 @@
 		}
 	} else {
 		if (iommu_meta->flags != iommu_flags) {
-			pr_err("%s: handle %p is already mapped with diff flag\n",
+			pr_err("%s: handle %pK is already mapped with diff flag\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
 		} else if (iommu_meta->mapped_size != iova_length) {
-			pr_err("%s: handle %p is already mapped with diff len\n",
+			pr_err("%s: handle %pK is already mapped with diff len\n",
 				__func__, handle);
 			ret = -EINVAL;
 			goto out_unlock;
@@ -1763,7 +1763,7 @@
 		data->addr += img->offset;
 		data->len -= img->offset;
 
-		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%x\n", img->memory_id,
+		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%x\n", img->memory_id,
 			 data->srcp_ihdl, &data->addr, data->len);
 	} else {
 		mdp3_put_img(data, client);
@@ -1968,7 +1968,7 @@
 		pr_err("fail to map to IOMMU %d\n", ret);
 		return ret;
 	}
-	pr_info("allocating %u bytes at %p (%lx phys) for fb %d\n",
+	pr_info("allocating %u bytes at %pK (%lx phys) for fb %d\n",
 		size, virt, phys, mfd->index);
 
 	mfd->fbi->screen_base = virt;
diff --git a/drivers/video/msm/mdss/mdp3_ppp_hwio.c b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
index 9c51eb4..6a22719 100644
--- a/drivers/video/msm/mdss/mdp3_ppp_hwio.c
+++ b/drivers/video/msm/mdss/mdp3_ppp_hwio.c
@@ -1239,7 +1239,8 @@
 	config_ppp_out(&blit_op->dst, yuv2rgb);
 
 	pr_debug("BLIT FG Param Fmt %d (x %d,y %d,w %d,h %d), ROI(x %d,y %d, w\
-		 %d, h %d) Addr_P0 %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
+		%d, h %d) Addr_P0 %pK, Stride S0 %d Addr_P1 %pK,\
+		Stride S1 %d\n",
 		blit_op->src.color_fmt, blit_op->src.prop.x, blit_op->src.prop.y,
 		blit_op->src.prop.width, blit_op->src.prop.height,
 		blit_op->src.roi.x, blit_op->src.roi.y, blit_op->src.roi.width,
@@ -1247,14 +1248,15 @@
                 blit_op->src.p1, blit_op->src.stride1);
 	if (blit_op->bg.p0 != blit_op->dst.p0)
 		pr_debug("BLIT BG Param Fmt %d (x %d,y %d,w %d,h %d), ROI(x %d,y %d, w\
-			 %d, h %d) Addr %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
+			 %d, h %d) Addr %pK, Stride S0 %d Addr_P1 %pK,\
+			 Stride S1 %d\n",
 			blit_op->bg.color_fmt, blit_op->bg.prop.x, blit_op->bg.prop.y,
 			blit_op->bg.prop.width, blit_op->bg.prop.height,
 			blit_op->bg.roi.x, blit_op->bg.roi.y, blit_op->bg.roi.width,
 			blit_op->bg.roi.height, blit_op->bg.p0, blit_op->bg.stride0,
 	                blit_op->bg.p1, blit_op->bg.stride1);
 	pr_debug("BLIT FB Param Fmt %d (x %d,y %d,w %d,h %d), ROI(x %d,y %d, w\
-		 %d, h %d) Addr %p, Stride S0 %d Addr_P1 %p, Stride S1 %d\n",
+		 %d, h %d) Addr %pK, Stride S0 %d Addr_P1 %pK, Stride S1 %d\n",
 		blit_op->dst.color_fmt, blit_op->dst.prop.x, blit_op->dst.prop.y,
 		blit_op->dst.prop.width, blit_op->dst.prop.height,
 		blit_op->dst.roi.x, blit_op->dst.roi.y, blit_op->dst.roi.width,
diff --git a/drivers/video/msm/mdss/mdss_debug.c b/drivers/video/msm/mdss/mdss_debug.c
index e07aeeb..80cc041 100644
--- a/drivers/video/msm/mdss/mdss_debug.c
+++ b/drivers/video/msm/mdss/mdss_debug.c
@@ -168,7 +168,7 @@
 	for (i = 0; i < len; i++) {
 		p = buf + i * 3;
 		p[2] = 0;
-		pr_debug("p[%d] = %p:%s\n", i, p, p);
+		pr_debug("p[%d] = %pK:%s\n", i, p, p);
 		cnt = sscanf(p, "%x", &tmp);
 		reg[i] = tmp;
 		pr_debug("reg[%d] = %x\n", i, (int)reg[i]);
@@ -1154,7 +1154,7 @@
 		return NULL;
 	}
 
-	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%p)\n",
+	pr_debug("MISR Module(%d) CTRL(0x%x) SIG(0x%x) intf_base(0x%pK)\n",
 			block_id, map->ctrl_reg, map->value_reg, intf_base);
 	return map;
 }
diff --git a/drivers/video/msm/mdss/mdss_debug_xlog.c b/drivers/video/msm/mdss/mdss_debug_xlog.c
index 7ba5ad7..3c31de4 100644
--- a/drivers/video/msm/mdss/mdss_debug_xlog.c
+++ b/drivers/video/msm/mdss/mdss_debug_xlog.c
@@ -235,7 +235,7 @@
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("bus dump_addr:%p size:%d\n",
+			pr_info("bus dump_addr:%pK size:%d\n",
 				dump_addr, list_size);
 		} else {
 			in_mem = false;
@@ -299,7 +299,7 @@
 
 		if (*dump_mem) {
 			dump_addr = *dump_mem;
-			pr_info("start_addr:%p end_addr:%p reg_addr=%p\n",
+			pr_info("start_addr:%pK end_addr:%pK reg_addr=%pK\n",
 				dump_addr, dump_addr + (u32)len * 16,
 				addr);
 		} else {
@@ -318,7 +318,7 @@
 		xc = readl_relaxed(addr+0xc);
 
 		if (in_log)
-			pr_info("%p : %08x %08x %08x %08x\n", addr, x0, x4, x8,
+			pr_info("%pK : %08x %08x %08x %08x\n", addr, x0, x4, x8,
 				xc);
 
 		if (dump_addr && in_mem) {
@@ -354,7 +354,7 @@
 			len = get_dump_range(&xlog_node->offset,
 				dbg->max_offset);
 			addr = dbg->base + xlog_node->offset.start;
-			pr_info("%s: range_base=0x%p start=0x%x end=0x%x\n",
+			pr_info("%s: range_base=0x%pK start=0x%x end=0x%x\n",
 				xlog_node->range_name,
 				addr, xlog_node->offset.start,
 				xlog_node->offset.end);
@@ -364,7 +364,7 @@
 	} else {
 		/* If there is no list to dump ranges, dump all registers */
 		pr_info("Ranges not found, will dump full registers");
-		pr_info("base:0x%p len:0x%zu\n", dbg->base, dbg->max_offset);
+		pr_info("base:0x%pK len:0x%zu\n", dbg->base, dbg->max_offset);
 		addr = dbg->base;
 		len = dbg->max_offset;
 		mdss_dump_reg(reg_dump_flag, addr, len, &dbg->reg_dump);
diff --git a/drivers/video/msm/mdss/mdss_dsi.c b/drivers/video/msm/mdss/mdss_dsi.c
index 42befe1..d28fc5a 100644
--- a/drivers/video/msm/mdss/mdss_dsi.c
+++ b/drivers/video/msm/mdss/mdss_dsi.c
@@ -97,7 +97,7 @@
 		return rc;
 	}
 
-	pr_debug("%s: lab=%p ibb=%p\n", __func__,
+	pr_debug("%s: lab=%pK ibb=%pK\n", __func__,
 				ctrl->lab, ctrl->ibb);
 
 	return 0;
@@ -629,7 +629,7 @@
 	mutex_lock(&ctrl_pdata->mutex);
 	panel_info = &ctrl_pdata->panel_data.panel_info;
 
-	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 	pr_info("%s[%d]+.\n", __func__, ctrl_pdata->ndx);
 
@@ -801,7 +801,7 @@
 				panel_data);
 
 	cur_power_state = pdata->panel_info.panel_power_state;
-	pr_debug("%s+: ctrl=%p ndx=%d cur_power_state=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d cur_power_state=%d\n", __func__,
 		ctrl_pdata, ctrl_pdata->ndx, cur_power_state);
 	pr_info("%s[%d]+.\n", __func__, ctrl_pdata->ndx);
 
@@ -966,7 +966,7 @@
 				panel_data);
 	mipi  = &pdata->panel_info.mipi;
 
-	pr_debug("%s+: ctrl=%p ndx=%d cur_blank_state=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d cur_blank_state=%d\n", __func__,
 		ctrl_pdata, ctrl_pdata->ndx, pdata->panel_info.blank_state);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, DSI_ALL_CLKS, 1);
@@ -1047,7 +1047,7 @@
 	/* Allow the panel to Power OFF during normal shutdown */
 	mdss_dsi_chk_shutdown_pending(pdata);
 
-	pr_debug("%s+: ctrl=%p ndx=%d power_state=%d\n",
+	pr_debug("%s+: ctrl=%pK ndx=%d power_state=%d\n",
 		__func__, ctrl_pdata, ctrl_pdata->ndx, power_state);
 
 	mdss_dsi_clk_ctrl(ctrl_pdata, DSI_ALL_CLKS, 1);
@@ -1123,7 +1123,7 @@
 	ctrl_pdata = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s+: ctrl=%p ndx=%d\n", __func__,
+	pr_debug("%s+: ctrl=%pK ndx=%d\n", __func__,
 				ctrl_pdata, ctrl_pdata->ndx);
 
 	WARN((ctrl_pdata->ctrl_state & CTRL_STATE_PANEL_INIT),
@@ -2101,10 +2101,10 @@
 		return rc;
 	}
 
-	pr_info("%s: ctrl_base=%p ctrl_size=%x phy_base=%p phy_size=%x\n",
+	pr_info("%s: ctrl_base=%pK ctrl_size=%x phy_base=%pK phy_size=%x\n",
 		__func__, ctrl->ctrl_base, ctrl->reg_size, ctrl->phy_io.base,
 		ctrl->phy_io.len);
-	pr_info("%s: phy_regulator_base=%p phy_regulator_size=%x\n", __func__,
+	pr_info("%s: phy_regulator_base=%pK phy_regulator_size=%x\n", __func__,
 		ctrl->shared_ctrl_data->phy_regulator_io.base,
 		ctrl->shared_ctrl_data->phy_regulator_io.len);
 
diff --git a/drivers/video/msm/mdss/mdss_dsi_host.c b/drivers/video/msm/mdss/mdss_dsi_host.c
index f98c1f8..422f34d 100644
--- a/drivers/video/msm/mdss/mdss_dsi_host.c
+++ b/drivers/video/msm/mdss/mdss_dsi_host.c
@@ -98,7 +98,7 @@
 	if (ctrl->mdss_util->register_irq(ctrl->dsi_hw))
 		pr_err("%s: mdss_register_irq failed.\n", __func__);
 
-	pr_debug("%s: ndx=%d base=%p\n", __func__, ctrl->ndx, ctrl->ctrl_base);
+	pr_debug("%s: ndx=%d base=%pK\n", __func__, ctrl->ndx, ctrl->ctrl_base);
 
 	init_completion(&ctrl->dma_comp);
 	init_completion(&ctrl->mdp_comp);
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index ef88227..936359c 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -959,7 +959,7 @@
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
 
-	pr_debug("%s: ctrl=%p ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
+	pr_debug("%s: ctrl=%pK ndx=%d enable=%d\n", __func__, ctrl, ctrl->ndx,
 		enable);
 
 	/* Any panel specific low power commands/config */
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
index 41ead5c..de9b1d4 100644
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -1919,7 +1919,7 @@
 		goto fb_mmap_failed;
 	}
 
-	pr_debug("alloc 0x%zuB vaddr = %p (%pa iova) for fb%d\n", fb_size,
+	pr_debug("alloc 0x%zuB vaddr = %pK (%pa iova) for fb%d\n", fb_size,
 			vaddr, &mfd->iova, mfd->index);
 
 	mfd->fbi->screen_base = (char *) vaddr;
@@ -2012,7 +2012,7 @@
 				vma->vm_page_prot =
 					pgprot_writecombine(vma->vm_page_prot);
 
-			pr_debug("vma=%p, addr=%x len=%ld\n",
+			pr_debug("vma=%pK, addr=%x len=%ld\n",
 					vma, (unsigned int)addr, len);
 			pr_debug("vm_start=%x vm_end=%x vm_page_prot=%ld\n",
 					(unsigned int)vma->vm_start,
@@ -2182,7 +2182,7 @@
 	if (rc)
 		pr_warn("Cannot map fb_mem %pa to IOMMU. rc=%d\n", &phys, rc);
 
-	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%p virt) (%pa iova) for fb%d\n",
+	pr_debug("alloc 0x%zxB @ (%pa phys) (0x%pK virt) (%pa iova) for fb%d\n",
 		 size, &phys, virt, &mfd->iova, mfd->index);
 
 	mfd->fbi->screen_base = virt;
diff --git a/drivers/video/msm/mdss/mdss_hdmi_tx.c b/drivers/video/msm/mdss/mdss_hdmi_tx.c
index 4dd111d..215a0af 100644
--- a/drivers/video/msm/mdss/mdss_hdmi_tx.c
+++ b/drivers/video/msm/mdss/mdss_hdmi_tx.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1109,7 +1109,7 @@
 		return rc;
 	}
 	hdmi_ctrl->kobj = &fbi->dev->kobj;
-	DEV_DBG("%s: sysfs group %p\n", __func__, hdmi_ctrl->kobj);
+	DEV_DBG("%s: sysfs group %pK\n", __func__, hdmi_ctrl->kobj);
 
 	return 0;
 } /* hdmi_tx_sysfs_create */
@@ -3649,7 +3649,7 @@
 			DEV_DBG("%s: '%s' remap failed or not available\n",
 				__func__, hdmi_tx_io_name(i));
 		}
-		DEV_INFO("%s: '%s': start = 0x%p, len=0x%x\n", __func__,
+		DEV_INFO("%s: '%s': start = 0x%pK, len=0x%x\n", __func__,
 			hdmi_tx_io_name(i), pdata->io[i].base,
 			pdata->io[i].len);
 	}
diff --git a/drivers/video/msm/mdss/mdss_hdmi_util.c b/drivers/video/msm/mdss/mdss_hdmi_util.c
index 2b2dbd7..70a7feb 100644
--- a/drivers/video/msm/mdss/mdss_hdmi_util.c
+++ b/drivers/video/msm/mdss/mdss_hdmi_util.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2010-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2010-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -364,7 +364,7 @@
 		return;
 	}
 
-	DEV_DBG("%s: buf=%p, d_len=0x%x, d_addr=0x%x, no_align=%d\n",
+	DEV_DBG("%s: buf=%pK, d_len=0x%x, d_addr=0x%x, no_align=%d\n",
 		caller, ddc_data->data_buf, ddc_data->data_len,
 		ddc_data->dev_addr, ddc_data->no_align);
 	DEV_DBG("%s: offset=0x%x, req_len=0x%x, retry=%d, what=%s\n",
diff --git a/drivers/video/msm/mdss/mdss_mdp.c b/drivers/video/msm/mdss/mdss_mdp.c
index ebb514f..1b98ed4 100644
--- a/drivers/video/msm/mdss/mdss_mdp.c
+++ b/drivers/video/msm/mdss/mdss_mdp.c
@@ -1418,7 +1418,7 @@
 
 	mdata->iclient = msm_ion_client_create(mdata->pdev->name);
 	if (IS_ERR_OR_NULL(mdata->iclient)) {
-		pr_err("msm_ion_client_create() return error (%p)\n",
+		pr_err("msm_ion_client_create() return error (%pK)\n",
 				mdata->iclient);
 		mdata->iclient = NULL;
 	}
@@ -1732,7 +1732,7 @@
 	if (rc)
 		pr_debug("unable to map MDSS VBIF non-realtime base\n");
 	else
-		pr_debug("MDSS VBIF NRT HW Base addr=%p len=0x%x\n",
+		pr_debug("MDSS VBIF NRT HW Base addr=%pK len=0x%x\n",
 			mdata->vbif_nrt_io.base, mdata->vbif_nrt_io.len);
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
diff --git a/drivers/video/msm/mdss/mdss_mdp_debug.c b/drivers/video/msm/mdss/mdss_mdp_debug.c
index f6a7e3e..24e8bd8 100644
--- a/drivers/video/msm/mdss/mdss_mdp_debug.c
+++ b/drivers/video/msm/mdss/mdss_mdp_debug.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -170,7 +170,7 @@
 		&buf->p[0].addr, buf->p[0].len);
 
 	if (buf->state != MDP_BUF_STATE_UNUSED)
-		seq_printf(s, "ihdl=0x%p ", buf->p[0].srcp_ihdl);
+		seq_printf(s, "ihdl=0x%pK ", buf->p[0].srcp_ihdl);
 
 	__print_time(tmpbuf, sizeof(tmpbuf), buf->last_alloc);
 	seq_printf(s, "alloc_time=%s ", tmpbuf);
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
index 35ee1e3..ce10597 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_cmd.c
@@ -688,7 +688,7 @@
 			ctx->rdptr_enabled, ctl->roi_bkup.w,
 			ctl->roi_bkup.h);
 
-	pr_debug("%s: intf_num=%d ctx=%p koff_cnt=%d\n", __func__,
+	pr_debug("%s: intf_num=%d ctx=%pK koff_cnt=%d\n", __func__,
 			ctl->intf_num, ctx, atomic_read(&ctx->koff_cnt));
 
 	rc = wait_event_timeout(ctx->pp_waitq,
@@ -1429,7 +1429,7 @@
 
 	ctx->intf_stopped = 0;
 
-	pr_debug("%s: ctx=%p num=%d\n", __func__, ctx, ctx->pp_num);
+	pr_debug("%s: ctx=%pK num=%d\n", __func__, ctx, ctx->pp_num);
 	MDSS_XLOG(ctl->num, atomic_read(&ctx->koff_cnt), ctx->clk_enabled,
 					ctx->rdptr_enabled);
 
diff --git a/drivers/video/msm/mdss/mdss_mdp_intf_video.c b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
index d3a2971..d8ba532 100644
--- a/drivers/video/msm/mdss/mdss_mdp_intf_video.c
+++ b/drivers/video/msm/mdss/mdss_mdp_intf_video.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -118,7 +118,7 @@
 
 	for (i = 0; i < count; i++) {
 		head[i].base = mdata->mdss_io.base + offsets[i];
-		pr_debug("adding Video Intf #%d offset=0x%x virt=%p\n", i,
+		pr_debug("adding Video Intf #%d offset=0x%x virt=%pK\n", i,
 				offsets[i], head[i].base);
 		head[i].ref_cnt = 0;
 		head[i].intf_num = i + MDSS_MDP_INTF0;
@@ -483,7 +483,7 @@
 		pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 		return -ENODEV;
 	}
-	pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num, ctx->intf_num,
+	pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num, ctx->intf_num,
 			ctx->base);
 
 	ret = mdss_mdp_video_ctx_stop(ctl, pinfo, ctx);
@@ -501,7 +501,7 @@
 			pr_err("Intf %d not in use\n", (inum + MDSS_MDP_INTF0));
 			return -ENODEV;
 		}
-		pr_debug("stop ctl=%d video Intf #%d base=%p", ctl->num,
+		pr_debug("stop ctl=%d video Intf #%d base=%pK", ctl->num,
 				ctx->intf_num, ctx->base);
 
 		ret = mdss_mdp_video_ctx_stop(ctl, pinfo, ctx);
@@ -1293,7 +1293,7 @@
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 	} else {
 		pr_err("Invalid intf number: %d\n", (inum + MDSS_MDP_INTF0));
@@ -1323,7 +1323,7 @@
 					(inum + MDSS_MDP_INTF0));
 			return -EBUSY;
 		}
-		pr_debug("video Intf #%d base=%p", ctx->intf_num, ctx->base);
+		pr_debug("video Intf #%d base=%pK", ctx->intf_num, ctx->base);
 		ctx->ref_cnt++;
 
 		ctl->intf_ctx[SLAVE_CTX] = ctx;
diff --git a/drivers/video/msm/mdss/mdss_mdp_overlay.c b/drivers/video/msm/mdss/mdss_mdp_overlay.c
index 7b47ec1..51ba7b7 100644
--- a/drivers/video/msm/mdss/mdss_mdp_overlay.c
+++ b/drivers/video/msm/mdss/mdss_mdp_overlay.c
@@ -1157,7 +1157,7 @@
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_used);
 	list_add_tail(&buf->pipe_list, &pipe->buf_queue);
 
-	pr_debug("buffer alloc: %p\n", buf);
+	pr_debug("buffer alloc: %pK\n", buf);
 
 	return buf;
 }
@@ -1210,7 +1210,7 @@
 	buf->last_freed = local_clock();
 	buf->state = MDP_BUF_STATE_UNUSED;
 
-	pr_debug("buffer freed: %p\n", buf);
+	pr_debug("buffer freed: %pK\n", buf);
 
 	list_move_tail(&buf->buf_list, &mdp5_data->bufs_pool);
 }
@@ -1542,7 +1542,7 @@
 		if (buf) {
 			switch (buf->state) {
 			case MDP_BUF_STATE_READY:
-				pr_debug("pnum=%d buf=%p first buffer ready\n",
+				pr_debug("pnum=%d buf=%pK first buffer ready\n",
 						pipe->num, buf);
 				break;
 			case MDP_BUF_STATE_ACTIVE:
@@ -1562,7 +1562,7 @@
 				}
 				break;
 			default:
-				pr_err("invalid state of buf %p=%d\n",
+				pr_err("invalid state of buf %pK=%d\n",
 						buf, buf->state);
 				BUG();
 				break;
diff --git a/drivers/video/msm/mdss/mdss_mdp_pipe.c b/drivers/video/msm/mdss/mdss_mdp_pipe.c
index 0f6baf6..4780d10 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pipe.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pipe.c
@@ -1833,7 +1833,7 @@
 	}
 
 	if (src_data == NULL) {
-		pr_debug("src_data=%p pipe num=%dx\n",
+		pr_debug("src_data=%pK pipe num=%dx\n",
 				src_data, pipe->num);
 		goto update_nobuf;
 	}
diff --git a/drivers/video/msm/mdss/mdss_mdp_pp.c b/drivers/video/msm/mdss/mdss_mdp_pp.c
index 524b7ab..1925de2 100644
--- a/drivers/video/msm/mdss/mdss_mdp_pp.c
+++ b/drivers/video/msm/mdss/mdss_mdp_pp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -1992,7 +1992,7 @@
 	struct msm_fb_data_type *bl_mfd;
 
 	if (!ctl || !ctl->mdata || !ctl->mfd) {
-		pr_err("invalid input: ctl = 0x%p, mdata = 0x%p, mfd = 0x%p\n",
+		pr_err("invalid input: ctl = 0x%pK, mdata = 0x%pK, mfd = 0x%pK\n",
 			ctl, (!ctl) ? NULL : ctl->mdata,
 			(!ctl) ? NULL : ctl->mfd);
 		return -EPERM;
@@ -2227,7 +2227,7 @@
 		pr_debug("AD not supported on device.\n");
 		return ret;
 	} else if (ret || !ad) {
-		pr_err("Failed to get ad info: ret = %d, ad = 0x%p.\n",
+		pr_err("Failed to get ad info: ret = %d, ad = 0x%pK.\n",
 			ret, ad);
 		return ret;
 	}
@@ -2242,7 +2242,7 @@
 	}
 
 	if (!ad->bl_mfd || !ad->bl_mfd->panel_info) {
-		pr_err("Invalid ad info: bl_mfd = 0x%p, ad->bl_mfd->panel_info = 0x%p\n",
+		pr_err("Invalid ad info: bl_mfd = 0x%pK, ad->bl_mfd->panel_info = 0x%pK\n",
 			ad->bl_mfd,
 			(!ad->bl_mfd) ? NULL : ad->bl_mfd->panel_info);
 		mutex_unlock(&ad->lock);
@@ -3603,7 +3603,7 @@
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_info("%s Hist collection has already been enabled %p\n",
+		pr_info("%s Hist collection has already been enabled %pK\n",
 			__func__, hist_info->base);
 		goto exit;
 	}
@@ -3746,7 +3746,7 @@
 	spin_lock_irqsave(&hist_info->hist_lock, flag);
 	if (hist_info->col_en == false) {
 		spin_unlock_irqrestore(&hist_info->hist_lock, flag);
-		pr_debug("Histogram already disabled (%p)\n", hist_info->base);
+		pr_debug("Histogram already disabled (%pK)\n", hist_info->base);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -3854,7 +3854,7 @@
 	unsigned long flag;
 	int ret = 0;
 	if (!intr) {
-		pr_err("NULL addr passed, %p\n", intr);
+		pr_err("NULL addr passed, %pK\n", intr);
 		return -EINVAL;
 	}
 
@@ -4608,7 +4608,7 @@
 
 	ret = mdss_mdp_get_ad(mfd, &ad);
 	if (ret || !ad) {
-		pr_err("Fail to get ad: ret = %d, ad = 0x%p\n", ret, ad);
+		pr_err("Fail to get ad: ret = %d, ad = 0x%pK\n", ret, ad);
 		return -EINVAL;
 	}
 	pr_debug("AD backlight level changed (%d), trigger update to AD\n",
diff --git a/drivers/video/msm/mdss/mdss_mdp_rotator.c b/drivers/video/msm/mdss/mdss_mdp_rotator.c
index 99c9c64..10ba5be 100644
--- a/drivers/video/msm/mdss/mdss_mdp_rotator.c
+++ b/drivers/video/msm/mdss/mdss_mdp_rotator.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -192,11 +192,11 @@
 			(free_rot_pipe->previous_session != rot);
 
 		rot_pipe = free_rot_pipe;
-		pr_debug("find a free pipe %p\n", rot_pipe->pipe);
+		pr_debug("find a free pipe %pK\n", rot_pipe->pipe);
 	} else {
 		rot_pipe = busy_rot_pipe;
 		if (rot_pipe)
-			pr_debug("find a busy pipe %p\n", rot_pipe->pipe);
+			pr_debug("find a busy pipe %pK\n", rot_pipe->pipe);
 	}
 
 	if (rot_pipe)
diff --git a/drivers/video/msm/mdss/mdss_mdp_util.c b/drivers/video/msm/mdss/mdss_mdp_util.c
index c2cbfdc..d8878ff 100644
--- a/drivers/video/msm/mdss/mdss_mdp_util.c
+++ b/drivers/video/msm/mdss/mdss_mdp_util.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -612,7 +612,7 @@
 		pr_debug("pmem buf=0x%pa\n", &data->addr);
 		data->srcp_file = NULL;
 	} else if (!IS_ERR_OR_NULL(data->srcp_ihdl)) {
-		pr_debug("ion hdl=%p buf=0x%pa\n", data->srcp_ihdl,
+		pr_debug("ion hdl=%pK buf=0x%pa\n", data->srcp_ihdl,
 							&data->addr);
 		if (!iclient) {
 			pr_err("invalid ion client\n");
@@ -704,8 +704,9 @@
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("mem=%d ihdl=%p buf=0x%pa len=0x%lx\n", img->memory_id,
-			 data->srcp_ihdl, &data->addr, data->len);
+		pr_debug("mem=%d ihdl=%pK buf=0x%pa len=0x%lx\n",
+			 img->memory_id, data->srcp_ihdl, &data->addr,
+			 data->len);
 	} else {
 		mdss_mdp_put_img(data);
 		return ret ? : -EOVERFLOW;
@@ -758,7 +759,7 @@
 		data->addr += data->offset;
 		data->len -= data->offset;
 
-		pr_debug("ihdl=%p buf=0x%pa len=0x%lx\n",
+		pr_debug("ihdl=%pK buf=0x%pa len=0x%lx\n",
 			 data->srcp_ihdl, &data->addr, data->len);
 	} else {
 		mdss_mdp_put_img(data);
diff --git a/drivers/video/msm/mdss/mdss_mdp_wb.c b/drivers/video/msm/mdss/mdss_mdp_wb.c
index 85eff89..7930587 100644
--- a/drivers/video/msm/mdss/mdss_mdp_wb.c
+++ b/drivers/video/msm/mdss/mdss_mdp_wb.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -95,7 +95,7 @@
 		ihdl = ion_alloc(iclient, img_size, SZ_4K,
 				 ION_HEAP(ION_SF_HEAP_ID), 0);
 		if (IS_ERR_OR_NULL(ihdl)) {
-			pr_err("unable to alloc fbmem from ion (%p)\n", ihdl);
+			pr_err("unable to alloc fbmem from ion (%pK)\n", ihdl);
 			return NULL;
 		}
 
@@ -122,7 +122,7 @@
 			img->len = img_size;
 		}
 
-		pr_debug("ihdl=%p virt=%p phys=0x%pa iova=0x%pa size=%u\n",
+		pr_debug("ihdl=%pK virt=%pK phys=0x%pa iova=0x%pa size=%u\n",
 			 ihdl, videomemory, &mdss_wb_mem, &img->addr, img_size);
 	}
 	return &mdss_wb_buffer;
@@ -435,7 +435,7 @@
 		list_for_each_entry(node, &wb->register_queue, registered_entry)
 			if ((node->buf_data.p[0].srcp_ihdl == ihdl) &&
 				    (node->buf_info.offset == data->offset)) {
-				pr_debug("found fd=%d hdl=%p off=%x addr=%pa\n",
+				pr_debug("found fd=%d hdl=%pK off=%x addr=%pa\n",
 						data->memory_id, ihdl,
 						data->offset,
 						&node->buf_data.p[0].addr);
@@ -501,7 +501,7 @@
 	if (node->user_alloc) {
 		buf = &node->buf_data.p[0];
 
-		pr_debug("free user mem_id=%d ihdl=%p, offset=%u addr=0x%pa\n",
+		pr_debug("free user mem_id=%d ihdl=%pK, offset=%u addr=0x%pa\n",
 				node->buf_info.memory_id,
 				buf->srcp_ihdl,
 				node->buf_info.offset,
diff --git a/drivers/video/msm/mdss/mdss_util.c b/drivers/video/msm/mdss/mdss_util.c
index 6d4e4f9..22c3803 100644
--- a/drivers/video/msm/mdss/mdss_util.c
+++ b/drivers/video/msm/mdss/mdss_util.c
@@ -1,5 +1,4 @@
-
-/* Copyright (c) 2007-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2007-2014,2016 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -33,7 +32,7 @@
 	if (!mdss_irq_handlers[hw->hw_ndx])
 		mdss_irq_handlers[hw->hw_ndx] = hw;
 	else
-		pr_err("panel %d's irq at %p is already registered\n",
+		pr_err("panel %d's irq at %pK is already registered\n",
 			hw->hw_ndx, hw->irq_handler);
 	spin_unlock_irqrestore(&mdss_lock, irq_flags);
 
diff --git a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
index 1514f02..04ba7a0 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_linux_tx.c
@@ -5599,7 +5599,7 @@
 	}
 
 	if (timer != timer_handle) {
-		MHL_TX_DBG_WARN("Invalid timer handle %p received\n",
+		MHL_TX_DBG_WARN("Invalid timer handle %pK received\n",
 				timer_handle);
 		return -EINVAL;
 	}
diff --git a/drivers/video/msm/mdss/mhl3/mhl_supp.c b/drivers/video/msm/mdss/mhl3/mhl_supp.c
index 7055d8c..29de6d0 100644
--- a/drivers/video/msm/mdss/mhl3/mhl_supp.c
+++ b/drivers/video/msm/mdss/mhl3/mhl_supp.c
@@ -185,7 +185,7 @@
 	req->function = function;
 	req->line = line;
 	req->sequence = dev_context->sequence++;
-	/*MHL_TX_DBG_ERR(,"q %d get:0x%p %s:%d\n",
+	/*MHL_TX_DBG_ERR(,"q %d get:0x%pK %s:%d\n",
 		req->sequence,req,function,line); */
 	return req;
 }
@@ -197,7 +197,7 @@
 					 struct cbus_req *pReq,
 					 const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->cbus_free_list);
 
 }
@@ -372,7 +372,7 @@
 	    sizeof(payload->as_bytes) -
 	    sizeof(struct SI_PACK_THIS_STRUCT standard_transport_header_t);
 	dev_context->block_protocol.marshalling_req = req;
-	MHL_TX_DBG_WARN("q %d get:0x%p %s:%d\n", req->sequence, req, function,
+	MHL_TX_DBG_WARN("q %d get:0x%pK %s:%d\n", req->sequence, req, function,
 			line);
 	return req;
 }
@@ -384,7 +384,7 @@
 					  struct block_req *pReq,
 					  const char *function, int line)
 {
-	/* MHL_TX_DBG_ERR(,"q ret:0x%p %s:%d\n",pReq,function,line); */
+	/* MHL_TX_DBG_ERR(,"q ret:0x%pK %s:%d\n",pReq,function,line); */
 	list_add(&pReq->link, &dev_context->block_protocol.free_list);
 
 }
@@ -1283,7 +1283,7 @@
 	if (req == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("req: %p\n", req);
+	MHL_TX_DBG_INFO("req: %pK\n", req);
 	/* coordinate write burst requests and grants. */
 	if (MHL_MSC_MSG == req->command) {
 		dev_context->msc_msg_last_data = req->msg_data[1];
@@ -1298,7 +1298,7 @@
 		}
 	}
 
-	MHL_TX_DBG_INFO("req: %p\n", req);
+	MHL_TX_DBG_INFO("req: %pK\n", req);
 	if (req) {
 		uint8_t ret_val;
 		dev_context->current_cbus_req = req;
diff --git a/drivers/video/msm/mdss/mhl3/platform.c b/drivers/video/msm/mdss/mhl3/platform.c
index 348be18..e384ce5 100644
--- a/drivers/video/msm/mdss/mhl3/platform.c
+++ b/drivers/video/msm/mdss/mhl3/platform.c
@@ -1590,7 +1590,7 @@
 {
 	int ret;
 
-	pr_info("%s(), i2c_device_id = %p\n", __func__, id);
+	pr_info("%s(), i2c_device_id = %pK\n", __func__, id);
 
 #if defined(SIMG_USE_DTS)
 	/*
@@ -1844,7 +1844,7 @@
 {
 	int ret;
 
-	pr_info("%s(), spi = %p\n", __func__, spi);
+	pr_info("%s(), spi = %pK\n", __func__, spi);
 	spi->bits_per_word = 8;
 	spi_dev = spi;
 	spi_bus_num = spi->master->bus_num;
@@ -2161,7 +2161,7 @@
 		for (idx = 0; idx < ARRAY_SIZE(device_addresses); idx++) {
 			MHL_TX_DBG_INFO("\n");
 			if (device_addresses[idx].client != NULL) {
-				MHL_TX_DBG_INFO("unregistering device:%p\n",
+				MHL_TX_DBG_INFO("unregistering device:%pK\n",
 						device_addresses[idx].client);
 				i2c_unregister_device(device_addresses[idx].
 						      client);
diff --git a/drivers/video/msm/mdss/mhl3/si_8620_drv.c b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
index dd71f1b..9d68f28 100644
--- a/drivers/video/msm/mdss/mhl3/si_8620_drv.c
+++ b/drivers/video/msm/mdss/mhl3/si_8620_drv.c
@@ -2367,7 +2367,7 @@
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 	offset += start;
 
-	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
 	if (EDID_BLOCK_SIZE == (offset + length))
 		hw_context->edid_fifo_block_number++;
 
@@ -2401,7 +2401,7 @@
 
 	offset = EDID_BLOCK_SIZE * (hw_context->edid_fifo_block_number & 0x01);
 
-	MHL_TX_DBG_INFO("%p %p\n", hw_context, edid_buf);
+	MHL_TX_DBG_INFO("%pK %pK\n", hw_context, edid_buf);
 	hw_context->edid_fifo_block_number++;
 
 #ifdef MANUAL_EDID_FETCH
diff --git a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
index 17d33c9..51e2eda 100644
--- a/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
+++ b/drivers/video/msm/mdss/mhl3/si_emsc_hid.c
@@ -461,7 +461,7 @@
 		return -ENODEV;
 
 	MHL3_HID_DBG_WARN("%s - HID_ACK reason code: %02X\n", __func__, reason);
-	MHL3_HID_DBG_ERR("mhid->mdev: %p\n", mhid->mdev);
+	MHL3_HID_DBG_ERR("mhid->mdev: %pK\n", mhid->mdev);
 	mhid->out_data[0] = MHL3_HID_ACK;
 	mhid->out_data[1] = reason;
 
@@ -1089,7 +1089,7 @@
 	mhl3_send_ack(mhid, HID_ACK_NODEV);
 
 	mhid->flags |= HID_FLAGS_WQ_CANCEL;
-	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %p\n", mhid);
+	MHL3_HID_DBG_ERR("WORK QUEUE function FAIL - mhid: %pK\n", mhid);
 	mhl3_disconnect_and_destroy_hid_device(mhid);
 
 	/*
diff --git a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
index 13d2a08..926ab6c 100644
--- a/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
+++ b/drivers/video/msm/mdss/mhl3/si_mdt_inputdev.c
@@ -80,10 +80,11 @@
 	if (dev_context->mdt_devs.dev_mouse == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
 			dev_context->mdt_devs.dev_mouse);
 	input_unregister_device(dev_context->mdt_devs.dev_mouse);
-	MHL_TX_DBG_INFO("Freeing mouse: %p\n", dev_context->mdt_devs.dev_mouse);
+	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
+		dev_context->mdt_devs.dev_mouse);
 	input_free_device(dev_context->mdt_devs.dev_mouse);
 	dev_context->mdt_devs.dev_mouse = NULL;
 }
@@ -93,10 +94,10 @@
 	if (dev_context->mdt_devs.dev_keyboard == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering keyboard: %p\n",
+	MHL_TX_DBG_INFO("Unregistering keyboard: %pK\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_unregister_device(dev_context->mdt_devs.dev_keyboard);
-	MHL_TX_DBG_INFO("Freeing keyboard: %p\n",
+	MHL_TX_DBG_INFO("Freeing keyboard: %pK\n",
 			dev_context->mdt_devs.dev_keyboard);
 	input_free_device(dev_context->mdt_devs.dev_keyboard);
 	dev_context->mdt_devs.dev_keyboard = NULL;
@@ -107,10 +108,10 @@
 	if (dev_context->mdt_devs.dev_touchscreen == NULL)
 		return;
 
-	MHL_TX_DBG_INFO("Unregistering mouse: %p\n",
+	MHL_TX_DBG_INFO("Unregistering mouse: %pK\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_unregister_device(dev_context->mdt_devs.dev_touchscreen);
-	MHL_TX_DBG_INFO("Freeing mouse: %p\n",
+	MHL_TX_DBG_INFO("Freeing mouse: %pK\n",
 			dev_context->mdt_devs.dev_touchscreen);
 	input_free_device(dev_context->mdt_devs.dev_touchscreen);
 	dev_context->mdt_devs.dev_touchscreen = NULL;
@@ -130,7 +131,7 @@
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated keyboard: %p\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Allocated keyboard: %pK\n", dev_keyboard);
 
 	set_bit(EV_KEY, dev_keyboard->evbit);
 	set_bit(EV_REP, dev_keyboard->evbit);
@@ -158,7 +159,7 @@
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered keyboard: %p\n", dev_keyboard);
+	MHL_TX_DBG_INFO("Registered keyboard: %pK\n", dev_keyboard);
 
 	dev_context->mdt_devs.dev_keyboard = dev_keyboard;
 
@@ -175,7 +176,7 @@
 		MHL_TX_DBG_ERR("Not enough memory\n");
 		return -ENOMEM;
 	}
-	MHL_TX_DBG_INFO("Allocated mouse: %p\n", dev_mouse);
+	MHL_TX_DBG_INFO("Allocated mouse: %pK\n", dev_mouse);
 
 	set_bit(EV_REL, dev_mouse->evbit);
 	set_bit(EV_KEY, dev_mouse->evbit);
@@ -208,7 +209,7 @@
 		return error;
 	}
 
-	MHL_TX_DBG_INFO("Registered mouse: %p\n", dev_mouse);
+	MHL_TX_DBG_INFO("Registered mouse: %pK\n", dev_mouse);
 
 	dev_context->mdt_devs.dev_mouse = dev_mouse;
 
@@ -226,7 +227,7 @@
 		return -ENOMEM;
 	}
 
-	MHL_TX_DBG_INFO("Allocated touch screen: %p\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Allocated touch screen: %pK\n", dev_touchscreen);
 
 #if !defined(SINGLE_TOUCH) && defined(KERNEL_2_6_38_AND_LATER)
 	input_mt_init_slots(dev_touchscreen, MAX_TOUCH_CONTACTS);
@@ -301,7 +302,7 @@
 		input_free_device(dev_touchscreen);
 		return error;
 	}
-	MHL_TX_DBG_INFO("Registered touchscreen: %p\n", dev_touchscreen);
+	MHL_TX_DBG_INFO("Registered touchscreen: %pK\n", dev_touchscreen);
 
 	dev_context->mdt_devs.dev_touchscreen = dev_touchscreen;
 
diff --git a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
index fd6918f..f9ece54 100644
--- a/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
+++ b/drivers/video/msm/mdss/mhl3/si_mhl2_edid_3d.c
@@ -1118,7 +1118,7 @@
 			if ((0 != p_desc->dtd.pixel_clock_low) ||
 				(0 != p_desc->dtd.pixel_clock_high)) {
 				MHL_TX_EDID_INFO(
-					"pix clock non-zero p_desc:%p", p_desc)
+					"pix clock non-zero p_desc:%pK", p_desc)
 				if ((0 == p_desc->dtd.horz_active_7_0) &&
 				    (0 == p_desc->dtd.horz_active_blanking_high.
 					horz_active_11_8)) {
@@ -1133,7 +1133,7 @@
 						 * one by one
 						 */
 						MHL_TX_EDID_INFO(
-						"p_desc:%p p_next_desc:%p\n",
+						"p_desc:%pK p_next_desc:%pK\n",
 						p_desc, p_next_desc)
 						*p_desc++ = *p_next_desc++;
 					}
@@ -1144,7 +1144,7 @@
 					p_desc = p_holder;
 				} else {
 					p_desc++;
-					MHL_TX_EDID_INFO("p_desc:%p\n", p_desc)
+					MHL_TX_EDID_INFO("p_desc:%pK\n", p_desc)
 				}
 			}
 		}
@@ -1446,7 +1446,7 @@
 			 * Mark this mode for pruning by setting
 			 * horizontal active to zero
 			 */
-			MHL_TX_DBG_ERR("%smark for pruning%s %p\n",
+			MHL_TX_DBG_ERR("%smark for pruning%s %pK\n",
 				ANSI_ESC_YELLOW_TEXT,
 				ANSI_ESC_RESET_TEXT,
 				p_desc);
@@ -1500,7 +1500,7 @@
 				++mhl_edid_3d_data->parse_data.
 				    num_cea_861_timing_dtds;
 			} else if (valid) {
-				MHL_TX_EDID_INFO("stopping at %p\n",
+				MHL_TX_EDID_INFO("stopping at %pK\n",
 					p_data_u.p_long_descriptors)
 				break;
 			}
@@ -1600,7 +1600,7 @@
 		HDMI_VIC_len = inner_loop_limit;
 	p_CEA_extension->byte_offset_to_18_byte_descriptors -=
 	    num_HDMI_VICs_pruned;
-	MHL_TX_EDID_INFO("%p\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
+	MHL_TX_EDID_INFO("%pK\n", mhl_edid_3d_data->parse_data.p_HDMI_vsdb);
 	if (mhl_edid_3d_data->parse_data.p_HDMI_vsdb) {
 		mhl_edid_3d_data->parse_data.p_HDMI_vsdb->
 		    header.fields.length_following_header -=
@@ -1722,8 +1722,7 @@
 					   ("\n\nInvalid extension size\n\n"));
 				while (pb_src < pb_limit) {
 					MHL_TX_EDID_INFO(
-					    "moving data up %p(0x%02X) "
-					    "<- %p(0x%02X)\n",
+					    "moving data up %pK(0x%02X)<- %pK(0x%02X)\n",
 					    pb_dest, (uint16_t)*pb_dest,
 					    pb_src, (uint16_t)*pb_src);
 					*pb_dest++ = *pb_src++;
@@ -3123,7 +3122,7 @@
 				     ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
 				return;
 			} else {
-				MHL_TX_DBG_WARN(" %d %p\n", hev_index,
+				MHL_TX_DBG_WARN(" %d %pK\n", hev_index,
 					mhl_edid_3d_data->hev_vic_list)
 				mhl_edid_3d_data->hev_vic_info.
 				    num_items_allocated =
@@ -3136,7 +3135,7 @@
 		MHL_TX_DBG_ERR("bogus write burst, no hev_vic_list\n")
 		return;
 	}
-	MHL_TX_DBG_WARN(" %d %p\n", hev_index, mhl_edid_3d_data->hev_vic_list)
+	MHL_TX_DBG_WARN(" %d %pK\n", hev_index, mhl_edid_3d_data->hev_vic_list)
 	if (NULL == mhl_edid_3d_data->hev_vic_list) {
 		MHL_TX_DBG_ERR("%s no place to put HEV_VIC burst%s\n",
 			       ANSI_ESC_RED_TEXT, ANSI_ESC_RESET_TEXT);
@@ -3155,7 +3154,7 @@
 		     burst_id_HEV_VIC,
 		     (union video_burst_descriptor_u *) &p_burst->
 		     video_descriptors[i])) {
-			MHL_TX_DBG_INFO(" %d %p\n",
+			MHL_TX_DBG_INFO(" %d %pK\n",
 				hev_index, mhl_edid_3d_data->hev_vic_list)
 			mhl_edid_3d_data->hev_vic_list[hev_index].
 			    mhl3_hev_vic_descriptor =
@@ -4036,7 +4035,8 @@
 
 	mhl_edid_3d_data->parse_data.p_HDMI_vsdb = NULL;
 
-	MHL_TX_EDID_INFO("tag:place holder EDID block:%p\n", p_EDID_block_data);
+	MHL_TX_EDID_INFO("tag:place holder EDID block:%pK\n",
+		p_EDID_block_data);
 	if (EDID_EXTENSION_BLOCK_MAP == p_CEA_extension->tag) {
 		struct block_map_t *p_block_map;
 		int i;
@@ -4123,7 +4123,7 @@
 		     mhl_edid_3d_data->parse_data.num_EDID_extensions;
 		     ++counter) {
 			MHL_TX_EDID_INFO
-			    (" counter:%d tag:place holder EDID block:%p\n",
+			    (" counter:%d tag:place holder EDID block:%pK\n",
 			     counter,
 			     &mhl_edid_3d_data->
 			     EDID_block_data[EDID_BLOCK_SIZE * counter]);
